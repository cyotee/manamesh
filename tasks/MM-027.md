# Task MM-027: Asset Pack Manifest Parser

**Repo:** ManaMesh
**Status:** Complete
**Created:** 2026-01-21
**Completed:** 2026-01-25
**Dependencies:** None
**Worktree:** `feature/asset-manifest-parser`

---

## Description

Implement the asset pack manifest parser that reads and validates manifest.json files according to the Asset Pack Format specification in the PRD.

## Dependencies

None

## User Stories

### US-MM-027.1: Parse Asset Pack Manifests

As a developer, I want to parse asset pack manifests so that I can load card assets dynamically.

**Acceptance Criteria:**
- [x] Parse root manifest.json structure
- [x] Parse card manifest entries
- [x] Validate manifest schema (required fields, types)
- [x] Handle nested manifests (subdirectory references)
- [x] Return typed AssetPackManifest object
- [x] Error handling for malformed manifests
- [x] Tests cover parsing and validation

### US-MM-027.2: Manifest Types

As a developer, I want TypeScript types for manifests so that I have type safety.

**Acceptance Criteria:**
- [x] AssetPackManifest interface
- [x] CardManifestEntry interface
- [x] Validation error types
- [x] Export from package

## Technical Details

### Manifest Structure (from PRD)

```typescript
interface AssetPackManifest {
  name: string;
  version: string;
  game: string;                    // 'mtg', 'lorcana', 'onepiece', 'poker', 'war'
  cards?: CardManifestEntry[];
  sets?: SetReference[];           // References to subdirectory manifests
}

interface CardManifestEntry {
  id: string;                      // Unique card identifier
  name: string;
  front: string;                   // Relative path to front image
  back?: string;                   // Relative path to back image (optional)
  metadata?: Record<string, unknown>;
}

interface SetReference {
  name: string;
  path: string;                    // Relative path to subdirectory manifest
}
```

### Functions to Implement

```typescript
// Parse and validate a manifest
function parseManifest(json: unknown): Result<AssetPackManifest, ValidationError[]>;

// Validate manifest schema
function validateManifest(manifest: unknown): ValidationError[];

// Resolve nested manifests into flat card list
function resolveNestedManifests(
  root: AssetPackManifest,
  loader: (path: string) => Promise<unknown>
): Promise<CardManifestEntry[]>;
```

## Files to Create/Modify

**New:**
- `packages/frontend/src/assets/manifest/types.ts` - Manifest types
- `packages/frontend/src/assets/manifest/parser.ts` - Parser implementation
- `packages/frontend/src/assets/manifest/validator.ts` - Schema validation
- `packages/frontend/src/assets/manifest/index.ts` - Exports

**Tests:**
- `packages/frontend/src/assets/manifest/parser.test.ts`
- `packages/frontend/src/assets/manifest/validator.test.ts`

## Completion Criteria

- [x] All acceptance criteria met
- [x] Parser handles valid manifests
- [x] Validator catches invalid manifests
- [x] Nested manifest resolution works
- [x] Tests pass (40 tests passing)
- [x] Build succeeds

---

## Implementation Notes

### Files Created

1. **types.ts** - Complete type definitions including:
   - `GameType` union type for supported games
   - `AssetPackManifest` interface
   - `CardManifestEntry` interface
   - `SetReference` interface
   - `ValidationError` and `ValidationErrorCode` types
   - `Result<T, E>` generic result type
   - `ManifestLoader` function type

2. **validator.ts** - Schema validation with:
   - `validateManifest()` - Full manifest validation
   - `validateCardEntry()` - Individual card validation
   - `validateSetReference()` - Set reference validation
   - `checkDuplicateIds()` - Duplicate card ID detection

3. **parser.ts** - Parsing and resolution:
   - `parseManifest()` - Parse unknown JSON to typed manifest
   - `parseManifestString()` - Parse JSON string
   - `resolveNestedManifests()` - Flatten nested set references
   - `getAllCardIds()` - Get all card IDs
   - `findCardById()` - Find specific card

4. **index.ts** - Clean re-exports of all public API

### Test Coverage

- 40 tests covering:
  - Valid manifest parsing
  - Missing/invalid field detection
  - Type validation
  - Empty value detection
  - Duplicate ID detection
  - Nested manifest resolution
  - Path adjustment for nested cards
  - Error handling for loader failures
